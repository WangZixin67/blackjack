var input[3] = [2,5,3];		// input for 2 player's initial hand, 1 dealer's visible hand
var card[10] = [4,4,4,4,4,4,4,4,4,16];
var gamer_point[2] = [0,0]; // gamer[0] for dealer, gamer[1] for player, count for total points
var gamer_hands[2] = [0,0];	// gamer[0] for dealer, gamer[1] for player, count the number of cards in hand
var flag = 2;				// to represent win, draw or lose state
var threshold = 16;

// drawing simulation process
Draw(i) = pcase{
    card[0]: draw.i{gamer_point[i]=gamer_point[i]+1;card[0]=card[0]-1;}->Skip
    card[1]: draw.i{gamer_point[i]=gamer_point[i]+2;card[1]=card[1]-1;}->Skip
    card[2]: draw.i{gamer_point[i]=gamer_point[i]+3;card[2]=card[2]-1;}->Skip
    card[3]: draw.i{gamer_point[i]=gamer_point[i]+4;card[3]=card[3]-1;}->Skip
    card[4]: draw.i{gamer_point[i]=gamer_point[i]+5;card[4]=card[4]-1;}->Skip
    card[5]: draw.i{gamer_point[i]=gamer_point[i]+6;card[5]=card[5]-1;}->Skip
    card[6]: draw.i{gamer_point[i]=gamer_point[i]+7;card[6]=card[6]-1;}->Skip
    card[7]: draw.i{gamer_point[i]=gamer_point[i]+8;card[7]=card[7]-1;}->Skip
    card[8]: draw.i{gamer_point[i]=gamer_point[i]+9;card[8]=card[8]-1;}->Skip
    card[9]: draw.i{gamer_point[i]=gamer_point[i]+10;card[9]=card[9]-1;}->Skip
};

// update the arrays and number of cards after initial input
UpdateInput = update{
	gamer_point[1] = gamer_point[1]+input[0]+input[1];
	gamer_hands[1] = gamer_hands[1] + 2;
	gamer_point[0] = gamer_point[0]+input[2];
	gamer_hands[0] = gamer_hands[0] + 1;
	card[input[0]-1]--;
	card[input[1]-1]--;
	card[input[2]-1]--;
} -> Skip;

GetInput = UpdateInput;
			(dealerDraw->Draw(0));
			[gamer_point[0]<=21]goNext->Skip[][gamer_point[0]>21]goesWin->Win;
			
PlayerHit(t) = [gamer_point[1]<t && gamer_hands[1] <5]playerDraw->Draw(1);PlayerHit(t)  // according to strategy, if total point not reach t player continue drawing
			[]
			[gamer_point[1] > 21]goLose->Lose		// if total point exceed 21 player busts and loses
			[]
			[gamer_point[1]>=t || gamer_hands[1] ==5]goNext->DealerHit();	// if player's total point reaches t or have 5 cards, dealer draws

// dealer must keep drawing until he gets 17 points or busts
DealerHit() = [gamer_point[0] < 17 && gamer_hands[0] < 5]dealerDraw->Draw(0);DealerHit()
			[]
			[gamer_point[0] > 21 || (gamer_point[0] < 17 && gamer_hands[0] == 5)]dealerLose->Win
			[]
			[gamer_point[0] >= 17 && gamer_hands[0] == 5]dealerWin->Lose
			[]
			[gamer_point[0] >= 17 && gamer_hands[0] < 5]compareResult->Compare();
			
Compare() = [gamer_point[0] == gamer_point[1]]goDrawn->Drawn
			[]
			[gamer_point[0] < gamer_point[1]]goWin->Win
			[]
			[gamer_point[0] > gamer_point[1]]goLose->Lose;
			
Game16 = GetInput;PlayerHit(16);
Game17 = GetInput;PlayerHit(17);
Game18 = GetInput;PlayerHit(18);
Game19 = GetInput;PlayerHit(19);
Game21 = GetInput;PlayerHit(21); // for simulation only

		
Win = set{flag = 1}->Skip;
Lose = set{flag = -1}->Skip;
Drawn = set{flag = 0}->Skip;


#define winning flag == 1;
#define losing  flag == -1;
#define drawing flag == 0;
			
#define goal16 gamer_point[1]>=16;
#assert Game16 reaches winning with prob;
#assert Game16 reaches losing with prob;
#assert Game16 reaches drawing with prob;

#define goal17 gamer_point[1]>=17;
#assert Game17 reaches winning with prob;
#assert Game17 reaches losing with prob;
#assert Game17 reaches drawing with prob;

#define goal18 gamer_point[1]>=18;
#assert Game18 reaches winning with prob;
#assert Game18 reaches losing with prob;
#assert Game18 reaches drawing with prob;

#define goal19 gamer_point[1]>=19;
#assert Game19 reaches winning with prob;
#assert Game19 reaches losing with prob;
#assert Game19 reaches drawing with prob;

#assert Game21 reaches winning with prob;
#assert Game21 reaches losing with prob;
#assert Game21 reaches drawing with prob;

    
    // What are the [min, max] reachabilities here?